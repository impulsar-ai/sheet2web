<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Video Gallery</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.0.2/papaparse.min.js"></script>
    <style>
        .aspect-ratio-16-9 {
            position: relative;
            width: 100%;
            padding-top: 56.25%;
        }

        .aspect-ratio-16-9 img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .responsive-iframe-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%;
        }

        .responsive-iframe-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }

        .scrollable-tags {
            max-height: 8rem;
            /* Altura basada en el tamaño típico de la fuente y el padding */
            overflow-y: auto;
            /* Habilita la barra de desplazamiento vertical si es necesario */
            display: flex;
            /* Utiliza flexbox para un mejor manejo de los elementos internos */
            flex-wrap: wrap;
            /* Permite que los elementos se ajusten en múltiples líneas */
            gap: 0.5rem;
            /* Espacio entre los tags */
            align-items: center;
            /* Alinea verticalmente los elementos */
            padding: 0.5rem;
            /* Espaciado interno para estética */
        }

        .loading-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; // Ajusta esto según necesites
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .spinner {
            border: 16px solid #f3f3f3;
            border-top: 16px solid #3498db;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
        }
    </style>
</head>

<body>
    <div id="app" class="p-5">
        <!-- Animación de loading -->
        <div v-if="isLoading" class="loading-container">
            Cargando...
        </div>
        <div class="mb-5 scrollable-tags">
            <span v-for="item in facetCounts" :key="item.facet"
                :class="{'bg-blue-500 text-white': activeFacets[item.facet], 'bg-gray-200 text-gray-700': !activeFacets[item.facet]}"
                class="inline-block rounded-full px-3 py-1 text-sm font-semibold mr-2 mb-2 cursor-pointer"
                @click="toggleFacet(item.facet)">
                {{ item.facet }} ({{ item.count }})
            </span>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div v-for="video in filteredVideos" :key="video.ID" class="max-w-sm rounded overflow-hidden shadow-lg">
                <div class="aspect-ratio-16-9">
                    <img :src="video.IMAGE" alt="Thumbnail" class="cursor-pointer" @click="showModal(video)">
                </div>
                <div class="px-6 py-4">
                    <div class="font-bold text-xl mb-2">
                        <a href="#" class="text-blue-700 hover:text-blue-900" @click.prevent="showModal(video)">
                            {{ video.TITLE }}
                        </a>
                    </div>
                    <p>{{ trimDescription(video.DESCRIPTION) }}</p>
                    <div class="mt-2">
                        <span
                            class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2"
                            v-for="facet in parseFacets(video.FACETS, video.TAGS)" :key="facet">{{ facet }}</span>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="selectedVideo" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full"
            @click.self="selectedVideo = null">
            <div class="relative top-20 mx-auto p-5 border w-3/4 shadow-lg rounded-md bg-white">
                <div class="responsive-iframe-container" v-html="selectedVideo.CONTENT">
                </div>
                <div class="mt-3 text-center">
                    <button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                        @click="selectedVideo = null">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        new Vue({
            el: '#app',
            data: {
                videos: [],
                selectedVideo: null,
                activeFacets: {},
                isLoading: true
            },
            computed: {
                facetCounts() {
                    const counts = {};
                    this.videos.forEach(video => {
                        const facets = this.parseFacets(video.FACETS, video.TAGS);
                        facets.forEach(facet => {
                            if (!counts[facet]) {
                                counts[facet] = 0;
                            }
                            counts[facet]++;
                        });
                    });
                    // Crear un array a partir del objeto counts para poder ordenarlo
                    const sortedFacets = Object.keys(counts).map(facet => ({
                        facet,
                        count: counts[facet]
                    }));
                    // Ordenar el array de mayor a menor basado en el count
                    sortedFacets.sort((a, b) => b.count - a.count);
                    // Convertirlo de nuevo en un objeto si es necesario o dejarlo como array para el v-for
                    return sortedFacets;
                },
                filteredVideos() {
                    if (Object.keys(this.activeFacets).length === 0) {
                        return this.videos;
                    }
                    return this.videos.filter(video => {
                        const facets = this.parseFacets(video.FACETS, video.TAGS);
                        return facets.some(facet => this.activeFacets[facet]);
                    });
                }
            },
            methods: {
                showModal(video) {
                    this.selectedVideo = video;
                },
                trimDescription(description) {
                    return description.length > 200 ? description.substr(0, 200) + '...' : description;
                },
                parseFacets(facetsString, tagsString) {
                    let facets = facetsString;
                    if (!facets || facets.trim() === '') {
                        facets = tagsString;
                    }
                    return facets ? facets.split(',').map(facet => facet.trim()) : [];
                },
                toggleFacet(facet) {
                    if (this.activeFacets[facet]) {
                        Vue.delete(this.activeFacets, facet);
                    } else {
                        Vue.set(this.activeFacets, facet, true);
                    }
                }
            },
            mounted() {
                this.isLoading = true;
                fetch('sheet_url.txt')
                    .then(response => response.text())
                    .then(url => {
                        fetch(url.trim()) // Asegura que no hay espacios en blanco alrededor de la URL
                            .then(response => response.text())
                            .then(csvData => {
                                Papa.parse(csvData, {
                                    header: true,
                                    skipEmptyLines: true,
                                    complete: (results) => {
                                        this.videos = results.data;
                                        this.isLoading = false;
                                    }
                                });
                            });
                    });
            }
        });
    </script>
</body>

</html>